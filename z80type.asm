; Z80TYPE.ASM - DETERMINE AND PRINT Z80 CPU TYPE
; WRITTEN BY SERGEY KISELEV <SKISELEV@GMAIL.COM>
;
; RUNS ON CP/M SYSTEMS WITH ZILOG Z80 AND COMPATIBLE PROCESSORS
; USES SIO INTERRUPT VECTOR REGISTER FOR TESTS
;
; BUILDING AND RUNNIG STEPS:
; A>ASM Z80TYPE
; A>LOAD Z80TYPE
; A>Z80TYPE

BDOS	EQU	5
WRCHR	EQU	2
WRSTR	EQU	9
; SIO CHANNEL B COMMAND PORT - RC2014/SC DEFAULT
SIOBC	EQU	82H

	ORG	0100H

	LXI	D,MSGSIGNIN
	MVI	C,WRSTR
	CALL	BDOS
	
; CHECK FOR U880

	LXI	H,0FFFFH
	LXI	B,00100H+SIOBC	; USE SIO CHANNEL B COMMAND PORT FOR TESTS

	DI
	MVI	A,02H		; SET SIO CHANNEL B REGISTER POINTER
				; TO REGISTER 2 - INTERRUPT VECTOR REGISTER
	OUT	SIOBC
	IN	SIOBC		; READ THE CURRENT INTERRUPT VECTOR
	STC
	DB	0EDH,0A3H	; Z80 OUTI INSTRUCTION
	PUSH	PSW		; SAVE THE ORIGINAL VECTOR ON THE STACK
	MVI	A,02H		; SET SIO CHANNEL B REGISTER POINTER
				; TO REGISTER 2 - INTERRUPT VECTOR REGISTER
	OUT	SIOBC
	POP	PSW		; RESTORE THE ORIGINAL INTERRUPT VECTOR
	OUT	SIOBC		; WRITE IT TO THE SIO
	EI
	JNC	Z80

; U880 DETECTED

	LXI	H,ISMME
	MVI	M,1		; SET MANUFACTURER MME FLAG
	LXI	D,MSGU880
	MVI	C,WRSTR
	CALL	BDOS
	JMP	CHKCMOS
	
Z80:
	LXI	D,MSGZ80
	MVI	C,WRSTR
	CALL	BDOS

CHKCMOS:
	LXI	D,MSGFAMILY
	MVI	C,WRSTR
	CALL	BDOS
; NMOS/CMOS CPU DETECTION ALGORITHM:
; 1. DISABLE INTERRUPTS
; 2. READ AND SAVE SIO CHANNEL B INTERRUPT VECTOR
; 3. MODIFY SIO CHANNEL B INTERRUPT VECTOR USING OUT (C),<0|0FFH>
;    (DB 0EDH, 071H) UNDOCMENTED INSTRUCTION:
;      ON AN NMOS CPU: OUT (C),0
;      ON A CMOS CPU: OUT (C),0FFH
; 4. READ AND SAVE SIO CHANNEL B INTERRUPT VECTOR
; 5. RESTORE SIO CHANNEL B INTERRUPT VECTOR
; 6. SET SIO REGISTER POINTER TO 0
; 7. ENABLE INTERRUPTS
; 8. CHECK THE VALUE READ BACK IN STEP 4
;      0 - NMOS CPU
;      0FFH - CMOS CPU
	DI
	MVI	A,02H		; SET SIO CHANNEL B REGISTER POINTER
				; TO REGISTER 2 - INTERRUPT VECTOR REGISTER
	OUT	SIOBC
	IN	SIOBC		; READ THE CURRENT INTERRUPT VECTOR
	MOV	B,A		; SAVE THE ORIGINAL VECTOR TO REGISTER B
	MVI	C,SIOBC
	DB	0EDH, 071H	; UNDOCUMENTED OUT (C),<0|0FFH> INSTRUCTION
				; WRITE 0 OR FF TO THE SIO INTERRUPT VECTOR
	MVI	A,02H		; SET SIO CHANNEL B REGISTER POINTER
				; TO REGISTER 2 - INTERRUPT VECTOR REGISTER
	OUT	SIOBC
	IN	SIOBC		; READ THE NEW INTERRUPT VECTOR
	MOV	C,A		; SAVE THE NEW VECTOR TO REGISTER B
	MVI	A,02H		; SET SIO CHANNEL B REGISTER POINTER
				; TO REGISTER 2 - INTERRUPT VECTOR REGISTER
	OUT	SIOBC
	MOV	A,B		; RESTORE THE ORIGINAL INTERRUPT VECTOR
	OUT	SIOBC		; WRITE IT TO THE SIO
	EI
	MOV	A,C		; VALUE WRITTEN BY OUT (C),<0|0FFH> INSTRUCTION
	CPI	00H		; IS IT ZERO?
	JNZ	CMOS

; NMOS DETECTED
	
	LXI	D,MSGNMOS
	MVI	C,WRSTR
	CALL	BDOS

; CHECK MANUFACTURER FOR NMOS CPUS
	
	LXI	D,MSGVENDOR
	MVI	C,WRSTR
	CALL	BDOS

; CHECK IF THE MANUFACTURER IS MME

	LXI	H,ISMME
	MOV	A,M
	CPI	1
	JNZ	NOTMME
	
	LXI	D,MSGMME
	MVI	C,WRSTR
	CALL	BDOS
	JMP	DONE

NOTMME:
	LXI	D,MSGNOTMME
	MVI	C,WRSTR
	CALL	BDOS
	JMP	DONE
	
CMOS:
	
	LXI	D,MSGCMOS
	MVI	C,WRSTR
	CALL	BDOS

; CHECK MANUFACTURER FOR CMOS CPUS

	LXI	D,MSGVENDOR
	MVI	C,WRSTR
	CALL	BDOS

; TEST SCF (STC) WHEN PREVIOUS INSTRUCTION DOESN'T MODIFY FLAGS
; POP AF (POP PSW) IS NOT TREATED AS FLAG MODIFYING INSTRUCTION

	LXI	D,2800H		; SET 'A' REGISTER BITS 3 AND 5
	CALL	TESTSCF
	CPI	29H		; FLAGS ON ZILOG CPU
	JZ	ZILOG
	CPI	09H		; FLAGS ON TOSHIBA (AND SOME NEC?) CPUS
	JZ	TOSHIBA
	CPI	01H		; FLAGS ON NEC CPU
	JZ	NEC

; UNRECOGNIZED CPU

	CALL	PRINTHEX	; PRINT FLAGS

	LXI	D,MSGUNKNOWN
	MVI	C,WRSTR
	CALL	BDOS
	JMP	DONE
		
ZILOG:
	LXI	D,MSGZILOG
	MVI	C,WRSTR
	CALL	BDOS
	JMP	DONE

TOSHIBA:
	LXI	D,MSGTOSHIBA
	MVI	C,WRSTR
	CALL	BDOS
	JMP	DONE
	
NEC:
	LXI	D,MSGNEC
	MVI	C,WRSTR
	CALL	BDOS
	
DONE:
	CALL	TESTFLAGS	; TEST HOW FLAGS SCF AFFECTS FLAGS
	RET			; RETURN TO CP/M

;-------------------------------------------------------------------------
; TESTFLAGS - TEST HOW SCF INSTRUCTION AFFECTS YF AND XF FLAGS
; NOTE: YF IS FLAGS.5 AND XF IS FLAGS.3
; INPUT:
;	NONE
; OUTPUT:
;	PRINTED ON CONSOLE
;-------------------------------------------------------------------------	
TESTFLAGS:
	LXI	D,MSGFLAGS
	MVI	C,WRSTR
	CALL	BDOS
	MVI	D,00H
LOOP1:
	MVI	E,00H
LOOP2:
	CALL	TESTSCF
	LXI	H,FLAGCOUNT	; POINT TO FLAG COUNTERS
	MVI	C,8		; NUMBER OF BITS / FLAGS
LOOP3:
	RRC			; LOWER BIT TO C
	JNC	LOOP4

	INR	M		; INCREMENT COUNTER IF FLAG IS SET
	JNZ	LOOP4		; NO OVERFLOW
	INX	H		; MOVE TO THE HIGH BIT
	INR	M		; INCREMENT HIGHER BIT
	JMP	LOOP5		; ALREADY INCREMENTED HL BY 1, SKIP NEXT INX H
LOOP4:
	INX	H		; MOVE TO THE NEXT COUNTER
LOOP5:
	INX	H
	DCR	C		; DECREMENT LOOP COUNTER
	JNZ	LOOP3		; LOOP COUNTER NOT ZERO - NEXT BIT
	INR	E		; INCREMENT DE
	JNZ	LOOP2
	INR	D
	JNZ	LOOP1
	
; PRINT VALUES
	MVI	C,16		; 16 DIGITS
	LXI	H,FLAGCOUNT+15	; POINT AT THE MSB
LOOP6:
	MOV	A,M
	CALL 	PRINTHEX
	DCX	H
	DCR	C
	JNZ	LOOP6		; PRINT NEXT DIGIT
	LXI	D,MSGCRLF
	MVI	C,WRSTR
	CALL	BDOS
	RET
	
;-------------------------------------------------------------------------
; TESTSCF - TEST HOW SCF INSTRUCTION AFFECTS YF AND XF FLAGS
; NOTE: YF IS FLAGS.5 AND XF IS FLAGS.3
; INPUT:
;	D - ACCUMULATOR VALUE BEFORE SCF
;	E - FLAGS VALUE BEFORE SCF
; OUTPUT:
;	A.0 - XF FLAG VALUE AFTER SCF
;	A.1 - YF FLAG VALUE AFTER SCF
;-------------------------------------------------------------------------
TESTSCF:
	PUSH	D
	DI
	MVI	A,0FEH
	ANA	D
	MOV	D,A
	MVI	A,0FEH
	ANA	E
	MOV	E,A
	PUSH	D		; PUSH DE TO THE STACK
	POP	PSW		; POP A AND FLAGS FROM THE STACK (DE)
	STC			; SET CF FLAG, DEPENDING ON THE CPU TYPE THIS
				; ALSO MIGHT CHANGE YF AND XF FLAGS
	PUSH	PSW		; STORE A AND F
	POP	D		; NEW FLAGS IN E
	EI
;	XRA	A		; ZERO A
;	DB	0CBH,5BH	; BIT 3,E - TEST IF XF IS SET
;	JNZ	TESTYF		; NOT SET
;	DB	0CBH,0C7H	; SET 0,A - SET BIT A.0
;TESTYF:
;	DB	0CBH,6BH	; BIT 5,E - TEST IF YF IS SET
;	JNZ	TESTSCF1
;	DB	0CBH,0CFH	; SET 1,A - SET BIT A.1
;TESTSCF1:
	MOV	A,E
	POP	D
	RET

;-------------------------------------------------------------------------
; PRINTHEX - PRINT BYTE IN HEXADECIMAL FORMAT
; INPUT:
;	A - BYTE TO PRINT
; OUTPUT:
;	NONE
;-------------------------------------------------------------------------
PRINTHEX:
	PUSH	B
	PUSH	D
	PUSH	H
	PUSH	PSW		; SAVE PRINTED VALUE ON THE STACK
	RRC			; ROTATE HIGHER 4 BITS TO LOWER 4 BITS
	RRC
	RRC
	RRC
	CALL	PRINTDIGIT	; PRINT HIGHER 4 BITS
	POP	PSW		; RESTORE PRINTED VALUE
	PUSH	PSW		; PUSH IT TO THE STACK AGAIN
	CALL	PRINTDIGIT	; PRINT LOWER 4 BITS
	POP	PSW	
	POP	H
	POP	D
	POP	B
	RET

;-------------------------------------------------------------------------	
; PRINTDIGIT - PRINT DIGIT IN HEXADECIMAL FORMAT
; INPUT:
;	A - DIGIT TO PRINT, LOWER 4 BITS 
; OUTPUT:
;	NONE
; TRASHES REGISTERS A, FLAGS, BC, DE, HL
;-------------------------------------------------------------------------	
PRINTDIGIT:
	ANI	0FH		; ISOLATE LOWER 4 BITS
	ADI	'0'		; CONVERT TO ASCII
	CPI	'9'+1		; GREATER THAN '9'?
	JC	PRINTIT
	ADI	'A'-'9'-1	; CONVERT A-F TO ASCII
	
PRINTIT:
	MOV	E,A
	MVI	C,WRCHR
	CALL	BDOS
	RET

FLAGCOUNT	DW	0,0,0,0,0,0,0,0
ISMME		DB	0
MSGSIGNIN:	DB	'Z80 Processor Type Detection (C) 2024 Sergey Kiselev',0DH,0AH
		DB	'Processor family: $'
MSGFAMILY:	DB	'Logic family:     $'
MSGVENDOR:	DB	'Manufacturer:     $'
MSGFLAGS:	DB	'SCF flags test:   $'
MSGU880:	DB	'U880',0DH,0AH,'$'
MSGZ80:		DB	'Z80',0DH,0AH,'$'
MSGNMOS:	DB	'NMOS',0DH,0AH,'$'
MSGCMOS:	DB	'CMOS',0DH,0AH,'$'
MSGMME:		DB	'MME or Thesys',0DH,0AH,'$'
MSGNOTMME:	DB	'Zilog or non-MME/Thesys clone',0DH,0AH,'$'
MSGZILOG:	DB	'Zilog or SGS/ST',0DH,0AH,'$'
MSGTOSHIBA:	DB	'Toshiba or NEC',0DH,0AH,'$'
MSGVM1		DB	'VM1',0DH,0AH,'$'
MSGNEC:		DB	'NEC',0DH,0AH,'$'
MSGUNKNOWN:	DB	' Unknown',0DH,0AH,'$'
MSGCRLF		DB	0DH,0AH,'$'

	END
